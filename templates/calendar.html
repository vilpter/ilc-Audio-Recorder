{% extends "base.html" %}

{% block title %}Church Recording - Schedule{% endblock %}

{% block page_subtitle %}Schedule{% endblock %}

{% block content %}
    <div class="container mx-auto p-6">
        <div class="bg-white rounded-lg shadow-md p-6">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-6">
                <h2 class="text-xl sm:text-2xl font-semibold">Recording Calendar</h2>
                <div class="flex space-x-2">
                    <button onclick="previousWeek()" class="bg-gray-300 hover:bg-gray-400 px-3 sm:px-4 py-2 rounded text-sm sm:text-base">
                        ← Prev
                    </button>
                    <button onclick="currentWeek()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 sm:px-4 py-2 rounded text-sm sm:text-base">
                        Today
                    </button>
                    <button onclick="nextWeek()" class="bg-gray-300 hover:bg-gray-400 px-3 sm:px-4 py-2 rounded text-sm sm:text-base">
                        Next →
                    </button>
                </div>
            </div>

            <div id="calendar-container">
                <!-- Calendar will be rendered here by JavaScript -->
            </div>

            <div class="mt-6 flex flex-wrap gap-3 sm:gap-4 text-xs sm:text-sm">
                <div class="flex items-center">
                    <div class="w-3 h-3 sm:w-4 sm:h-4 bg-blue-200 border border-blue-400 rounded mr-1 sm:mr-2"></div>
                    <span>Future</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 sm:w-4 sm:h-4 bg-orange-200 border border-orange-400 rounded mr-1 sm:mr-2"></div>
                    <span>Recording Now</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 sm:w-4 sm:h-4 bg-green-200 border border-green-400 rounded mr-1 sm:mr-2"></div>
                    <span>Completed</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 sm:w-4 sm:h-4 bg-yellow-200 border border-yellow-400 rounded mr-1 sm:mr-2"></div>
                    <span>Missed</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 sm:w-4 sm:h-4 bg-red-200 border border-red-400 rounded mr-1 sm:mr-2"></div>
                    <span>Failed</span>
                </div>
                <div class="flex items-center">
                    <div class="w-3 h-3 sm:w-4 sm:h-4 bg-purple-200 border border-purple-400 rounded mr-1 sm:mr-2"></div>
                    <span>Recurring</span>
                </div>
            </div>
        </div>

        <!-- Selected Event Details -->
        <div id="event-details" class="hidden mt-6 bg-white rounded-lg shadow-md p-6">
            <h3 id="event-details-heading" class="text-xl font-semibold mb-4">Event Details</h3>
            <div id="event-info"></div>
        </div>

        <!-- Create/Edit Schedule Modal -->
        <div id="create-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100] p-4">
            <div class="bg-white rounded-lg shadow-xl p-4 sm:p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 id="modal-title" class="text-xl font-semibold">Create New Recording</h3>
                    <button onclick="closeModal()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>
                <input type="hidden" id="modal-edit-id" value="">
                
                <div class="space-y-4">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label class="block text-gray-700 mb-2">Recording Name *</label>
                            <input type="text" id="modal-name" placeholder="e.g., Morning Show"
                                class="w-full border border-gray-300 rounded px-3 py-2">
                        </div>
                        
                        <div>
                            <label class="block text-gray-700 mb-2">Date *</label>
                            <div class="relative">
                                <input type="date" id="modal-date"
                                    class="w-full border border-gray-300 rounded px-3 py-2"
                                    onchange="updateDayOfWeek()">
                                <div id="day-of-week-display" class="text-sm text-gray-600 mt-1"></div>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-gray-700 mb-2">Time *</label>
                            <input type="time" id="modal-time" value="09:00"
                                class="w-full border border-gray-300 rounded px-3 py-2">
                        </div>
                        
                        <div>
                            <label class="block text-gray-700 mb-2">Duration (minutes) *</label>
                            <input type="number" id="modal-duration" value="60" min="1"
                                class="w-full border border-gray-300 rounded px-3 py-2"
                                oninput="checkModalDurationWarning()">
                        </div>
                        
                        <div class="col-span-1 md:col-span-2">
                            <label class="block text-gray-700 mb-2">Notes</label>
                            <input type="text" id="modal-notes" placeholder="Optional notes"
                                class="w-full border border-gray-300 rounded px-3 py-2">
                        </div>
                    </div>
                    
                    <!-- Recurring options -->
                    <div class="border-t pt-4">
                        <label class="flex items-center mb-2">
                            <input type="checkbox" id="modal-recurring" onchange="toggleModalRecurring()" class="mr-2">
                            <span class="text-gray-700 font-medium">Make this a recurring schedule</span>
                        </label>
                        
                        <div id="modal-recurring-options" class="hidden ml-6 space-y-3">
                            <div>
                                <select id="modal-recurrence-type" onchange="updateModalRecurring()" class="border rounded px-3 py-2">
                                    <option value="weekly">Weekly</option>
                                    <option value="daily">Daily</option>
                                    <option value="monthly">Monthly</option>
                                </select>
                            </div>
                            
                            <div id="modal-weekly-options">
                                <div class="hidden">
                                    <!-- Hidden checkboxes - automatically set based on selected date -->
                                    <label class="flex items-center">
                                        <input type="checkbox" value="0" class="modal-weekday mr-1"> Mon
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" value="1" class="modal-weekday mr-1"> Tue
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" value="2" class="modal-weekday mr-1"> Wed
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" value="3" class="modal-weekday mr-1"> Thu
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" value="4" class="modal-weekday mr-1"> Fri
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" value="5" class="modal-weekday mr-1"> Sat
                                    </label>
                                    <label class="flex items-center">
                                        <input type="checkbox" value="6" class="modal-weekday mr-1"> Sun
                                    </label>
                                </div>
                                <p class="text-sm text-gray-600 italic">
                                    <span id="weekly-day-display" class="font-medium"></span> will be automatically selected based on the date you chose above.
                                </p>
                            </div>
                            
                            <div id="modal-monthly-options" class="hidden">
                                <div class="hidden">
                                    <!-- Hidden input - automatically set based on selected date -->
                                    <input type="number" id="modal-month-day" value="1" min="1" max="31"
                                        class="border rounded px-3 py-2 w-24">
                                </div>
                                <p class="text-sm text-gray-600 italic">
                                    Day <span id="monthly-day-display" class="font-medium"></span> of each month will be automatically selected based on the date you chose above.
                                </p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Video Capture Option -->
                    <div class="border-t pt-4">
                        <label class="flex items-center">
                            <input type="checkbox" id="modal-capture-video" class="mr-2">
                            <span class="text-gray-700 font-medium">Also capture video</span>
                        </label>
                        <p class="text-xs text-gray-500 mt-1 ml-6">
                            Requires camera to be configured in Settings. Video will be saved to USB storage.
                        </p>
                    </div>

                    <!-- Duration Warning -->
                    <div id="modal-duration-warning" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
                        <strong>Warning:</strong> Recording duration exceeds 4 hours.
                        Long recordings require significant disk space (~345 MB/hour per channel).
                    </div>

                    <div class="flex justify-end space-x-3 pt-4 border-t">
                        <button onclick="closeModal()" class="px-4 py-2 border rounded hover:bg-gray-100">
                            Cancel
                        </button>
                        <button id="modal-submit-btn" onclick="saveFromModal()" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded">
                            Create Recording
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block extra_scripts %}
    <script>
        let currentDate = new Date();
        let allJobs = {{ jobs | tojson | safe }};
        let allInstances = {{ instances | tojson | safe }};

        // Format time range for calendar cells (compact: "10:00 AM - 11:30 AM")
        function formatTimeRangeShort(startTimeStr, durationSeconds) {
            const startTime = new Date(startTimeStr);
            const endTime = new Date(startTime.getTime() + durationSeconds * 1000);
            const formatOptions = { hour: '2-digit', minute: '2-digit', hour12: true };
            const startFormatted = startTime.toLocaleTimeString('en-US', formatOptions);
            const endFormatted = endTime.toLocaleTimeString('en-US', formatOptions);
            return `${startFormatted} - ${endFormatted}`;
        }

        // Format time range for event details (full: "Jan 20, 2026, 10:00 AM - 11:30 AM")
        function formatTimeRangeFull(startTimeStr, durationSeconds) {
            const startTime = new Date(startTimeStr);
            const endTime = new Date(startTime.getTime() + durationSeconds * 1000);
            const formatOptions = { hour: '2-digit', minute: '2-digit', hour12: true };
            const dateOptions = { month: 'short', day: 'numeric', year: 'numeric' };
            const dateFormatted = startTime.toLocaleDateString('en-US', dateOptions);
            const startFormatted = startTime.toLocaleTimeString('en-US', formatOptions);
            const endFormatted = endTime.toLocaleTimeString('en-US', formatOptions);
            return `${dateFormatted}, ${startFormatted} - ${endFormatted}`;
        }

        function renderCalendar() {
            const container = document.getElementById('calendar-container');
            const startOfWeek = getStartOfWeek(currentDate);

            let html = '<div class="overflow-x-auto">';

            // Render 4 weeks
            for (let week = 0; week < 4; week++) {
                const weekStart = new Date(startOfWeek);
                weekStart.setDate(weekStart.getDate() + (week * 7));

                html += `<div class="mb-6">`;
                html += `<h3 class="font-semibold text-gray-700 mb-2 text-sm sm:text-base">Week of ${formatDate(weekStart)}</h3>`;
                html += `<div class="grid grid-cols-7 gap-1 sm:gap-2 min-w-[500px] sm:min-w-0">`;

                // Day headers
                const days = window.innerWidth < 640 ? ['M', 'T', 'W', 'T', 'F', 'S', 'S'] : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                days.forEach(day => {
                    html += `<div class="font-semibold text-center text-xs sm:text-sm text-gray-600 p-1 sm:p-2">${day}</div>`;
                });

                // Days
                for (let day = 0; day < 7; day++) {
                    const currentDay = new Date(weekStart);
                    currentDay.setDate(currentDay.getDate() + day);

                    const isToday = isSameDay(currentDay, new Date());
                    const eventsOnDay = getEventsForDay(currentDay);

                    html += `<div class="border rounded p-1 sm:p-2 min-h-16 sm:min-h-24 cursor-pointer hover:bg-gray-50 ${isToday ? 'bg-yellow-50 border-yellow-400' : 'bg-white border-gray-200'}"
                             onclick='openCreateModal(${JSON.stringify(formatDateForInput(currentDay))})'>`;
                    html += `<div class="text-xs sm:text-sm font-semibold ${isToday ? 'text-yellow-900' : 'text-gray-700'}">${currentDay.getDate()}</div>`;

                    eventsOnDay.forEach(event => {
                        // Calculate time-based color
                        const now = getCurrentTime();
                        const dayStr = currentDay.toISOString().split('T')[0];

                        // For recurring jobs, check if there's an instance for this specific date
                        let instance = null;
                        if (event.is_recurring) {
                            instance = allInstances.find(i =>
                                i.parent_job_id === event.id &&
                                i.occurrence_date === dayStr
                            );
                        }

                        // Calculate occurrence-specific times
                        const jobStartTime = new Date(event.start_time);
                        const startTime = event.is_recurring
                            ? new Date(currentDay.getFullYear(), currentDay.getMonth(), currentDay.getDate(),
                                      jobStartTime.getHours(), jobStartTime.getMinutes(), jobStartTime.getSeconds())
                            : new Date(event.start_time);
                        const endTime = new Date(startTime.getTime() + event.duration * 1000);

                        let bgColor;
                        if (event.is_recurring && instance) {
                            // Use instance status for color
                            if (instance.status === 'completed') {
                                bgColor = 'bg-green-200 border-green-400';
                            } else if (instance.status === 'failed') {
                                bgColor = 'bg-red-200 border-red-400';
                            } else if (instance.status === 'missed') {
                                bgColor = 'bg-yellow-200 border-yellow-400';
                            } else {
                                bgColor = 'bg-purple-200 border-purple-400';
                            }
                        } else if (event.is_recurring && !instance && endTime < now) {
                            // Past recurring occurrence with no instance - likely missed
                            bgColor = 'bg-yellow-200 border-yellow-400';
                        } else if (event.is_recurring) {
                            // Future recurring occurrence
                            bgColor = 'bg-purple-200 border-purple-400';
                        } else if (now < startTime) {
                            // Future recording
                            bgColor = 'bg-blue-200 border-blue-400';
                        } else if (now >= endTime) {
                            // Recording time passed - check notes for success/failure
                            if (event.notes && (event.notes.includes('Last executed:') || event.notes.includes('Recording completed'))) {
                                bgColor = 'bg-green-200 border-green-400'; // Completed successfully
                            } else if (event.notes && (event.notes.includes('failed') || event.notes.includes('error'))) {
                                bgColor = 'bg-red-200 border-red-400'; // Failed
                            } else {
                                bgColor = 'bg-yellow-200 border-yellow-400'; // Missed or unknown
                            }
                        } else {
                            // Currently in recording window
                            bgColor = 'bg-orange-200 border-orange-400';
                        }

                        const typeIndicator = event.capture_video ? 'A&V' : 'A';
                        const currentDayStr = currentDay.toISOString();
                        html += `<div class="${bgColor} border rounded px-1 sm:px-2 py-0.5 sm:py-1 mb-1 text-xs cursor-pointer hover:opacity-80"
                                     onclick='event.stopPropagation(); showEventDetails(${JSON.stringify(event)}, "${currentDayStr}")'>`;
                        html += `<div class="font-semibold truncate">${event.name} <span class="opacity-60">[${typeIndicator}]</span></div>`;
                        html += `<div class="hidden sm:block">${formatTimeRangeShort(event.start_time, event.duration)}</div>`;
                        html += `</div>`;
                    });

                    html += `</div>`;
                }

                html += `</div></div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function getStartOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Monday as first day
            return new Date(d.setDate(diff));
        }

        function isSameDay(date1, date2) {
            return date1.getFullYear() === date2.getFullYear() &&
                   date1.getMonth() === date2.getMonth() &&
                   date1.getDate() === date2.getDate();
        }

        function getEventsForDay(day) {
            const dayStr = day.toISOString().split('T')[0];
            const now = getCurrentTime();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

            return allJobs.filter(job => {
                if (job.is_recurring) {
                    // For past dates, check if an instance exists
                    if (day < today) {
                        const instance = allInstances.find(i =>
                            i.parent_job_id === job.id &&
                            i.occurrence_date === dayStr
                        );
                        return !!instance;  // Only show if instance exists
                    }

                    // For future dates (and today), use pattern matching
                    if (job.recurrence_pattern) {
                        try {
                            const pattern = JSON.parse(job.recurrence_pattern);
                            if (pattern.type === 'daily') return true;
                            if (pattern.type === 'weekly') {
                                const dayOfWeek = (day.getDay() + 6) % 7; // Convert to Mon=0, Sun=6
                                return pattern.days && pattern.days.includes(dayOfWeek);
                            }
                            if (pattern.type === 'monthly') {
                                return day.getDate() === pattern.day;
                            }
                        } catch (e) {
                            console.error('Error parsing pattern:', e);
                        }
                    }
                    return false;
                } else {
                    // For one-time jobs, check if dates match
                    const jobDate = new Date(job.start_time);
                    return isSameDay(day, jobDate);
                }
            });
        }

        function formatDate(date) {
            return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
        }

        async function showEventDetails(event, clickedDateStr) {
            const detailsDiv = document.getElementById('event-details');
            const headingEl = document.getElementById('event-details-heading');
            const infoDiv = document.getElementById('event-info');

            headingEl.textContent = event.name;

            // Parse the clicked date
            const clickedDate = new Date(clickedDateStr);
            const occurrenceDate = clickedDate.toISOString().split('T')[0];

            // For recurring jobs, ensure instance exists and get instance data
            let instance = null;
            if (event.is_recurring) {
                try {
                    const response = await fetch(`/api/schedule/${event.id}/occurrence/${occurrenceDate}`);
                    const data = await response.json();
                    instance = data.instance;

                    if (data.was_created) {
                        console.log(`Instance was auto-created for ${event.id} on ${occurrenceDate}`);
                        // Refresh instances data
                        const indexResponse = await fetch('/');
                        // Note: We can't easily re-parse the page, but the instance is now available
                    }

                    // Update allInstances if instance was created or found
                    if (instance) {
                        const existingIndex = allInstances.findIndex(i =>
                            i.parent_job_id === event.id && i.occurrence_date === occurrenceDate
                        );
                        if (existingIndex >= 0) {
                            allInstances[existingIndex] = instance;
                        } else {
                            allInstances.push(instance);
                        }
                    }
                } catch (error) {
                    console.error('Error fetching/creating instance:', error);
                }
            }

            // Calculate occurrence-specific times
            const jobStartTime = new Date(event.start_time);
            const startTime = event.is_recurring
                ? new Date(clickedDate.getFullYear(), clickedDate.getMonth(), clickedDate.getDate(),
                          jobStartTime.getHours(), jobStartTime.getMinutes(), jobStartTime.getSeconds())
                : new Date(event.start_time);
            const endTime = new Date(startTime.getTime() + event.duration * 1000);

            // Determine status and notes to display
            const now = getCurrentTime();
            let statusText = '';
            let statusClass = '';
            let statusDetails = '';
            let isFutureRecording = false;
            let notesToDisplay = '';

            if (instance) {
                // Use instance-specific status and notes
                notesToDisplay = instance.notes || '';

                if (instance.status === 'completed') {
                    statusText = 'RECORDING COMPLETED';
                    statusClass = 'text-green-600';
                    statusDetails = 'Recording was successful';
                } else if (instance.status === 'failed') {
                    statusText = 'RECORDING FAILED';
                    statusClass = 'text-red-600';
                    statusDetails = 'Recording encountered an error';
                } else if (instance.status === 'missed') {
                    statusText = 'RECORDING MISSED';
                    statusClass = 'text-yellow-600';
                    statusDetails = 'Recording did not execute';
                } else {
                    statusText = 'PENDING';
                    statusClass = 'text-blue-600';
                }
            } else {
                // No instance - calculate status from times
                notesToDisplay = event.notes || '';

                if (now < startTime) {
                    // Future recording
                    statusText = 'FUTURE RECORDING';
                    statusClass = 'text-blue-600';
                    isFutureRecording = true;
                    const timeUntil = Math.floor((startTime - now) / 1000 / 60);
                    if (timeUntil < 60) {
                        statusDetails = `Starts in ${timeUntil} minutes`;
                    } else if (timeUntil < 1440) {
                        statusDetails = `Starts in ${Math.floor(timeUntil / 60)} hours`;
                    } else {
                        statusDetails = `Starts in ${Math.floor(timeUntil / 1440)} days`;
                    }
                } else if (now >= startTime && now < endTime) {
                    // Should be recording now - verify with /api/status
                    statusText = 'CURRENTLY RECORDING';
                    statusClass = 'text-orange-600 animate-pulse';

                    // Cross-reference with /api/status
                    try {
                        const statusResponse = await fetch('/api/status');
                        const statusData = await statusResponse.json();

                        if (!statusData.recording) {
                            statusText = 'RECORDING WINDOW ACTIVE (but not recording)';
                            statusClass = 'text-yellow-600';
                            statusDetails = 'Warning: Should be recording but /api/status shows no active recording';
                        } else {
                            const timeRemaining = Math.floor((endTime - now) / 1000 / 60);
                            statusDetails = `${timeRemaining} minutes remaining`;
                        }
                    } catch (error) {
                        console.error('Error checking recording status:', error);
                        statusDetails = 'Unable to verify recording status';
                    }
                } else {
                    // Recording time passed
                    statusText = 'RECORDING TIME PASSED';
                    statusClass = 'text-gray-600';

                    // Check notes for execution information (for non-recurring or legacy data)
                    if (notesToDisplay) {
                        if (notesToDisplay.includes('Last executed:') || notesToDisplay.includes('Recording completed')) {
                            statusClass = 'text-green-600';
                            statusDetails = 'Recording completed';
                        } else if (notesToDisplay.includes('failed') || notesToDisplay.includes('error')) {
                            statusClass = 'text-red-600';
                            statusDetails = 'Recording failed - see notes';
                        } else {
                            statusClass = 'text-yellow-600';
                            statusDetails = 'Status unknown - check notes';
                        }
                    } else {
                        statusClass = 'text-red-600';
                        statusDetails = 'No execution record found - recording may have been missed';
                    }
                }
            }

            let recurrenceInfo = '';
            if (event.is_recurring && event.recurrence_pattern) {
                try {
                    const pattern = JSON.parse(event.recurrence_pattern);
                    if (pattern.type === 'daily') {
                        recurrenceInfo = 'Repeats daily';
                    } else if (pattern.type === 'weekly') {
                        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
                        const dayNames = pattern.days.map(d => days[d]).join(', ');
                        recurrenceInfo = `Repeats weekly on ${dayNames}`;
                    } else if (pattern.type === 'monthly') {
                        recurrenceInfo = `Repeats monthly on day ${pattern.day}`;
                    }
                } catch (e) {
                    recurrenceInfo = 'Recurring schedule';
                }
            }

            const recordingType = event.capture_video ? 'Audio & Video' : 'Audio only';
            const occurrenceTimeStr = formatTimeRangeFull(startTime.toISOString(), event.duration);

            infoDiv.innerHTML = `
                <div class="space-y-2">
                    <div><strong>Time:</strong> ${occurrenceTimeStr}</div>
                    <div><strong>Duration:</strong> ${event.duration / 60} minutes</div>
                    <div><strong>Type:</strong> ${recordingType}</div>
                    <div><strong>Status:</strong> <span class="font-semibold ${statusClass}">${statusText}</span>
                        ${statusDetails ? `<br><span class="text-sm text-gray-600">${statusDetails}</span>` : ''}
                    </div>
                    ${recurrenceInfo ? `<div><strong>Recurrence:</strong> ${recurrenceInfo}</div>` : ''}
                    ${notesToDisplay ? `<div><strong>Notes:</strong> ${notesToDisplay}</div>` : ''}
                    ${isFutureRecording ? `
                        <div class="mt-4 flex space-x-2">
                            <button onclick='openEditModal(${JSON.stringify(event).replace(/'/g, "&#39;")})' class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
                                Edit
                            </button>
                            <button onclick="deleteEvent('${event.id}')" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded">
                                Delete
                            </button>
                        </div>
                    ` : ''}
                </div>
            `;

            detailsDiv.classList.remove('hidden');
            detailsDiv.scrollIntoView({ behavior: 'smooth' });
        }

        function previousWeek() {
            currentDate.setDate(currentDate.getDate() - 7);
            renderCalendar();
        }

        function nextWeek() {
            currentDate.setDate(currentDate.getDate() + 7);
            renderCalendar();
        }

        function currentWeek() {
            currentDate = new Date();
            renderCalendar();
        }

        function formatDateForInput(date) {
            return date.toISOString().split('T')[0];
        }

        function checkModalDurationWarning() {
            const duration = parseInt(document.getElementById('modal-duration').value) || 0;
            const warning = document.getElementById('modal-duration-warning');
            if (duration > 240) {  // 4 hours = 240 minutes
                warning.classList.remove('hidden');
            } else {
                warning.classList.add('hidden');
            }
        }

        function openCreateModal(dateStr) {
            // Reset to create mode
            document.getElementById('modal-edit-id').value = '';
            document.getElementById('modal-title').textContent = 'Create New Recording';
            document.getElementById('modal-submit-btn').textContent = 'Create Recording';

            document.getElementById('modal-date').value = dateStr;
            document.getElementById('modal-name').value = '';
            document.getElementById('modal-time').value = '09:00';
            document.getElementById('modal-duration').value = '60';
            document.getElementById('modal-notes').value = '';
            document.getElementById('modal-recurring').checked = false;
            document.getElementById('modal-capture-video').checked = false;
            document.getElementById('modal-duration-warning').classList.add('hidden');

            // Clear weekday checkboxes
            document.querySelectorAll('.modal-weekday').forEach(cb => cb.checked = false);
            document.getElementById('modal-recurrence-type').value = 'weekly';
            document.getElementById('modal-month-day').value = '1';

            // Update day of week display
            updateDayOfWeek();

            toggleModalRecurring();

            document.getElementById('create-modal').classList.remove('hidden');
        }

        function openEditModal(event) {
            // Set to edit mode
            document.getElementById('modal-edit-id').value = event.id;
            document.getElementById('modal-title').textContent = 'Edit Recording';
            document.getElementById('modal-submit-btn').textContent = 'Save Changes';

            // Parse start time
            const startTime = new Date(event.start_time);
            const dateStr = startTime.toISOString().split('T')[0];
            const timeStr = startTime.toTimeString().substring(0, 5);

            document.getElementById('modal-date').value = dateStr;
            document.getElementById('modal-name').value = event.name;
            document.getElementById('modal-time').value = timeStr;
            document.getElementById('modal-duration').value = Math.floor(event.duration / 60);
            document.getElementById('modal-notes').value = event.notes || '';
            document.getElementById('modal-recurring').checked = event.is_recurring;
            document.getElementById('modal-capture-video').checked = event.capture_video;

            // Update day of week display
            updateDayOfWeek();

            // Handle duration warning
            checkModalDurationWarning();

            // Handle recurring options
            if (event.is_recurring && event.recurrence_pattern) {
                try {
                    const pattern = JSON.parse(event.recurrence_pattern);
                    document.getElementById('modal-recurrence-type').value = pattern.type;

                    // Clear all weekday checkboxes first
                    document.querySelectorAll('.modal-weekday').forEach(cb => cb.checked = false);

                    if (pattern.type === 'weekly' && pattern.days) {
                        pattern.days.forEach(day => {
                            const cb = document.querySelector(`.modal-weekday[value="${day}"]`);
                            if (cb) cb.checked = true;
                        });
                        // Update display text to show the selected day from pattern
                        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                        if (pattern.days.length > 0) {
                            document.getElementById('weekly-day-display').textContent = dayNames[pattern.days[0]];
                        }
                    } else if (pattern.type === 'monthly' && pattern.day) {
                        document.getElementById('modal-month-day').value = pattern.day;
                        // Update display text to show the selected day from pattern
                        document.getElementById('monthly-day-display').textContent = pattern.day;
                    }
                } catch (e) {
                    console.error('Error parsing recurrence pattern:', e);
                }
            } else {
                // Clear weekday checkboxes
                document.querySelectorAll('.modal-weekday').forEach(cb => cb.checked = false);
                document.getElementById('modal-recurrence-type').value = 'weekly';
                document.getElementById('modal-month-day').value = '1';
            }

            toggleModalRecurring();

            // Hide event details panel
            document.getElementById('event-details').classList.add('hidden');

            document.getElementById('create-modal').classList.remove('hidden');
        }

        function closeModal() {
            document.getElementById('create-modal').classList.add('hidden');
        }

        function updateDayOfWeek() {
            const dateInput = document.getElementById('modal-date');
            const dayDisplay = document.getElementById('day-of-week-display');

            if (!dateInput.value) {
                dayDisplay.textContent = '';
                return;
            }

            const selectedDate = new Date(dateInput.value + 'T00:00:00');
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayName = dayNames[selectedDate.getDay()];

            dayDisplay.textContent = dayName;

            // If recurring is checked, update the recurring options too
            if (document.getElementById('modal-recurring').checked) {
                updateModalRecurring();
            }
        }

        function toggleModalRecurring() {
            const isRecurring = document.getElementById('modal-recurring').checked;
            const options = document.getElementById('modal-recurring-options');
            options.classList.toggle('hidden', !isRecurring);
            if (isRecurring) updateModalRecurring();
        }

        function updateModalRecurring() {
            const type = document.getElementById('modal-recurrence-type').value;
            const dateInput = document.getElementById('modal-date');

            document.getElementById('modal-weekly-options').classList.toggle('hidden', type !== 'weekly');
            document.getElementById('modal-monthly-options').classList.toggle('hidden', type !== 'monthly');

            // Auto-populate based on selected date
            if (!dateInput.value) return;

            const selectedDate = new Date(dateInput.value + 'T00:00:00');
            const dayOfWeek = selectedDate.getDay();
            const dayOfMonth = selectedDate.getDate();
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

            if (type === 'weekly') {
                // Clear all weekday checkboxes first
                document.querySelectorAll('.modal-weekday').forEach(cb => cb.checked = false);

                // Check the box for the selected day
                document.querySelectorAll('.modal-weekday').forEach(cb => {
                    if (parseInt(cb.value) === dayOfWeek) {
                        cb.checked = true;
                    }
                });

                // Update the display text
                document.getElementById('weekly-day-display').textContent = dayNames[dayOfWeek];
            } else if (type === 'monthly') {
                // Set the day of month
                document.getElementById('modal-month-day').value = dayOfMonth;

                // Update the display text
                document.getElementById('monthly-day-display').textContent = dayOfMonth;
            }
        }

        async function saveFromModal() {
            const editId = document.getElementById('modal-edit-id').value;
            const isEditMode = editId !== '';

            const name = document.getElementById('modal-name').value;
            const date = document.getElementById('modal-date').value;
            const time = document.getElementById('modal-time').value;
            const duration = parseInt(document.getElementById('modal-duration').value) * 60;
            const notes = document.getElementById('modal-notes').value;
            const isRecurring = document.getElementById('modal-recurring').checked;
            const captureVideo = document.getElementById('modal-capture-video').checked;
            const allowOverride = duration > 14400;  // Auto-allow if > 4 hours (user saw warning)

            if (!name) {
                alert('Please enter a recording name');
                return;
            }

            const startTime = `${date}T${time}`;
            let recurrencePattern = null;

            if (isRecurring) {
                const type = document.getElementById('modal-recurrence-type').value;
                const pattern = { type };

                if (type === 'weekly') {
                    const days = Array.from(document.querySelectorAll('.modal-weekday:checked'))
                                     .map(cb => parseInt(cb.value));
                    if (days.length === 0) {
                        alert('Please select at least one day for weekly recurrence');
                        return;
                    }
                    pattern.days = days;
                } else if (type === 'monthly') {
                    pattern.day = parseInt(document.getElementById('modal-month-day').value);
                }

                recurrencePattern = JSON.stringify(pattern);
            }

            try {
                let response;
                if (isEditMode) {
                    // Update existing schedule
                    response = await fetch(`/api/schedule/${editId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name,
                            start_time: startTime,
                            duration,
                            notes,
                            is_recurring: isRecurring,
                            recurrence_pattern: recurrencePattern,
                            allow_override: allowOverride,
                            capture_video: captureVideo
                        })
                    });
                } else {
                    // Create new schedule
                    response = await fetch('/api/schedule', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name,
                            start_time: startTime,
                            duration,
                            notes,
                            is_recurring: isRecurring,
                            recurrence_pattern: recurrencePattern,
                            allow_override: allowOverride,
                            capture_video: captureVideo
                        })
                    });
                }

                const result = await response.json();

                if (result.error) {
                    alert('Error: ' + result.error);
                } else {
                    closeModal();
                    location.reload(); // Refresh to show changes
                }
            } catch (error) {
                alert('Error saving schedule: ' + error);
            }
        }

        async function deleteEvent(jobId) {
            if (!confirm('Are you sure you want to delete this scheduled recording?')) {
                return;
            }

            try {
                const response = await fetch(`/api/schedule/${jobId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();

                if (result.error) {
                    alert('Error: ' + result.error);
                } else {
                    location.reload(); // Refresh to remove deleted event
                }
            } catch (error) {
                alert('Error deleting schedule: ' + error);
            }
        }

        // Initial render
        renderCalendar();

        // Re-render on resize for responsive day headers
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(renderCalendar, 250);
        });

        // Auto-refresh calendar every 60 seconds to update time-based colors
        setInterval(renderCalendar, 60000);
    </script>
{% endblock %}
